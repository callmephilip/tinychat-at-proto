import { Agent, RichText } from "@atproto/api";
import { z } from "zod";
import { createUtfString, getUtf8Length, sliceUtf8 } from "tinychat/utils.ts";
import type { Main as AppBskyRichtextFacet } from "@tinychat/lexicons/types/app/bsky/richtext/facet.ts";
// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: bsky.ipynb

const profileSchema = z.object({
  did: z.string(),
  handle: z.string(),
  displayName: z.string().optional(),
  avatar: z.string().optional(),
  labels: z.array(z.string()),
  createdAt: z.string(),
  description: z.string().optional(),
  banner: z.string().optional(),
  followersCount: z.number(),
  followsCount: z.number(),
  postsCount: z.number(),
});

export type Profile = z.infer<typeof profileSchema>;

export const getProfile = async (did: string): Promise<Profile> => {
  const { data } = await (new Agent("https://public.api.bsky.app/xrpc"))
    .getProfile({ actor: did });
  return profileSchema.parse(data);
};

export const getRichText = async (text: string): Promise<RichText> => {
  const rt = new RichText({ text });
  await rt.detectFacets(new Agent("https://public.api.bsky.app/xrpc"));
  return rt;
};

type UnwrapArray<T> = T extends (infer V)[] ? V : never;

export type Facet = AppBskyRichtextFacet;
export type FacetFeature = UnwrapArray<Facet["features"]>;

export interface RichtextSegment {
  text: string;
  feature: FacetFeature | undefined;
}

const createSegment = (
  text: string,
  feature: FacetFeature | undefined,
): RichtextSegment => {
  return { text: text, feature: feature };
};

export const segmentRichText = (
  rtText: string,
  facets: Facet[] | undefined,
): RichtextSegment[] => {
  if (facets === undefined || facets.length === 0) {
    return [createSegment(rtText, undefined)];
  }

  const text = createUtfString(rtText);

  const segments: RichtextSegment[] = [];
  const length = getUtf8Length(text);

  const facetsLength = facets.length;

  let textCursor = 0;
  let facetCursor = 0;

  do {
    const facet = facets[facetCursor];
    const { byteStart, byteEnd } = facet.index;

    if (textCursor < byteStart) {
      segments.push(
        createSegment(sliceUtf8(text, textCursor, byteStart), undefined),
      );
    } else if (textCursor > byteStart) {
      facetCursor++;
      continue;
    }

    if (byteStart < byteEnd) {
      const subtext = sliceUtf8(text, byteStart, byteEnd);
      const features = facet.features;

      if (features.length === 0 || subtext.trim().length === 0) {
        segments.push(createSegment(subtext, undefined));
      } else {
        segments.push(createSegment(subtext, features[0]));
      }
    }

    textCursor = byteEnd;
    facetCursor++;
  } while (facetCursor < facetsLength);

  if (textCursor < length) {
    segments.push(
      createSegment(sliceUtf8(text, textCursor, length), undefined),
    );
  }

  return segments;
};
