import { z } from "zod";
import { Record as Message } from "tinychat/api/types/chat/tinychat/core/message.ts";
import { atURIFromParts, getTimeus } from "tinychat/utils.ts";
import { Jetstream } from "@skyware/jetstream";
import { ids } from "tinychat/api/lexicons.ts";
import type { Database } from "tinychat/db.ts";
import { fetchView } from "tinychat/db.ts";
import { MessageView, validateMessageView } from "tinychat/core/base.ts";
import { syncUser } from "tinychat/core/users.ts";
import EventEmitter from "node:events";
// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: core/messaging.ipynb

const newMessageRecordSchema = z.object({
  did: z.string(),
  time_us: z.number(),
  commit: z.object({
    rev: z.string(),
    operation: z.string(),
    collection: z.string(),
    rkey: z.string(),
    cid: z.string().optional(),
    record: z.custom<Message>(),
  }),
}).transform((d) => {
  if (!d.commit) {
    throw new Error(`Invalid record: ${JSON.stringify(d, null, 2)}`);
  }
  return Object.assign({}, d, {
    time_us: `${d.time_us}`,
    uri: atURIFromParts({
      did: d.did,
      collection: d.commit.collection,
      rkey: d.commit.rkey,
    }),
  });
});

type NewMessageRecord = z.infer<typeof newMessageRecordSchema>;

const deleteMessageRecordSchema = z
  .object({
    did: z.string(),
    time_us: z.number(),
    commit: z.object({
      rev: z.string(),
      operation: z.string(),
      collection: z.string(),
      rkey: z.string(),
      cid: z.string().optional(),
    }),
  })
  .transform((d) => {
    if (!d.commit) {
      throw new Error(`Invalid record: ${JSON.stringify(d, null, 2)}`);
    }
    return Object.assign({}, d, {
      uri: atURIFromParts({
        did: d.did,
        collection: d.commit.collection,
        rkey: d.commit.rkey,
      }),
    });
  });

type DeleteMessageRecord = z.infer<typeof deleteMessageRecordSchema>;

export class MessageCursor {
  constructor(public timestamp: string, public direction: "past" | "future") {}

  public static fromString(base64Str: string): MessageCursor {
    const decoded = atob(base64Str);
    const [timestamp, direction] = decoded.split(":");
    return new MessageCursor(timestamp, direction as "past" | "future");
  }

  public toString(): string {
    return btoa(`${this.timestamp}:${this.direction}`);
  }
}

export class Messaging extends EventEmitter {
  constructor(protected db: Database) {
    super();
  }

  public connectToJetstream(jetstream: Jetstream) {
    jetstream.on(ids.ChatTinychatCoreMessage, async (event) => {
      // we only do creates for now
      if (event.commit.operation === "create") {
        const data = newMessageRecordSchema.parse(event);
        await syncUser({ did: event.did, db: this.db });
        this.receiveMessage(
          Object.assign({}, data, {
            cid: data.commit.cid!,
            m: data.commit.record,
            sender: event.did,
          }),
        );
      } else if (event.commit.operation === "delete") {
        this.deleteMessage(deleteMessageRecordSchema.parse(event));
      }
    });
  }

  public deleteMessage({ uri }: DeleteMessageRecord) {
    this.db
      .prepare(
        `UPDATE messages SET deleted_at = :time, text = '<deleted>' WHERE uri = :uri`,
      )
      .run({ uri, time: new Date().toISOString() });
  }

  public markAllMessagesAsRead({
    channel,
    server,
    user,
  }: {
    channel: string;
    server: string;
    user: string;
  }) {
    this.db
      .prepare(
        `INSERT OR REPLACE INTO read_receipts (channel, server, user, time_us) VALUES (:channel, :server, :user, :time)`,
      )
      .run({ channel, user, server, time: getTimeus() });
  }

  public receiveMessage({
    m,
    cid,
    uri,
    sender,
    time_us,
  }: {
    m: Message;
    cid: string;
    uri: string;
    sender: string;
    time_us: string;
  }) {
    this.db
      .prepare(
        `
      INSERT INTO messages (uri, cid, channel, server, text, sender, created_at, time_us, reply_to, facets, embed, langs, labels, tags) VALUES (
        :uri, :cid, :channel, :server, :text, :sender, :created_at, :time_us, :reply_to, :facets, :embed, :langs, :labels, :tags 
      )`,
      )
      .run({
        uri,
        cid,
        channel: m.channel,
        server: m.server,
        text: m.text,
        sender,
        created_at: m.createdAt,
        time_us: time_us,
        reply_to: m.reply ? m.reply.parent.uri : null,
        facets: m.facets ? JSON.stringify(m.facets) : null,
        embed: m.embed ? JSON.stringify(m.embed) : null,
        langs: m.langs ? JSON.stringify(m.langs) : null,
        labels: m.labels ? JSON.stringify(m.labels) : null,
        tags: m.tags ? JSON.stringify(m.tags) : null,
      });
    this.emit("message", { uri });
  }

  public getMessages({
    server,
    channel,
    parent,
    uri,
    cursor,
    limit,
    sort = "latest",
  }: {
    server?: string;
    channel?: string;
    parent?: string;
    uri?: string;
    cursor?: string;
    limit?: number;
    sort?: "latest" | "chronological";
  }): {
    messages: MessageView[];
    prevCursor?: string;
    nextCursor?: string;
  } {
    if (!channel && !server && !uri) {
      return {
        messages: [],
      };
    }

    const parsedCursor = cursor && MessageCursor.fromString(cursor);
    const cursorWhere = (c: MessageCursor) =>
      c.direction === "past" ? `ts < ${c.timestamp}` : `ts > ${c.timestamp}`;
    let messages: MessageView[] = [];

    if (uri) {
      messages = fetchView<MessageView>({
        db: this.db,
        sql: `SELECT * FROM message_view WHERE uri = '${uri}'`,
        validate: validateMessageView,
      });
    } else {
      messages = fetchView<MessageView>({
        db: this.db,
        sql: `SELECT * FROM message_view WHERE ${
          parent ? `reply_to = '${parent}'` : "reply_to IS NULL"
        } AND channel = '${channel}' AND server = '${server}' ${
          parsedCursor ? `AND ${cursorWhere(parsedCursor)}` : ""
        } ORDER BY ${sort === "chronological" ? "ts ASC" : "ts DESC"} LIMIT ${
          limit || 10
        }`,
        validate: validateMessageView,
      });
    }

    if (sort === "latest") {
      return Object.assign(
        {
          messages,
        },
        messages.length === limit
          ? {
            prevCursor: new MessageCursor(
              messages[messages.length - 1].ts,
              "past",
            ).toString(),
          }
          : {},
        cursor
          ? {
            nextCursor: new MessageCursor(
              messages[0].ts,
              "future",
            ).toString(),
          }
          : {},
      );
    }

    // chronological ordering
    // need to check if we have older messages for the prev cursor

    const hasPreviousMessages = messages.length !== 0 &&
      this.db
          .prepare(
            `SELECT uri FROM message_view
          WHERE ${
              parent ? `reply_to = '${parent}'` : "reply_to IS NULL"
            } AND channel = :channel AND server = :server AND ts < :time_us
          ORDER BY ts DESC LIMIT :limit`,
          )
          .all<{ uri: string }>({
            channel,
            server,
            time_us: messages[0].ts,
            limit: 1,
          }).length > 0;

    return Object.assign(
      {
        messages,
      },
      messages.length === limit
        ? {
          nextCursor: new MessageCursor(
            messages[messages.length - 1].ts,
            "future",
          ).toString(),
        }
        : {},
      hasPreviousMessages
        ? {
          prevCursor: new MessageCursor(messages[0].ts, "past").toString(),
        }
        : {},
    );
  }
}
