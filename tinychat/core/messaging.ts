import { z } from "zod";
import { Record as Message } from "tinychat/api/types/chat/tinychat/core/message.ts";
import { atURIFromParts, getTimeus, removeNulls } from "tinychat/utils.ts";
import { Jetstream } from "@skyware/jetstream";
import { ids } from "tinychat/api/lexicons.ts";
import type { Database } from "tinychat/db.ts";
import {
  MessageView,
  validateMessageView,
} from "tinychat/api/types/chat/tinychat/server/defs.ts";
import { syncUser } from "tinychat/core/users.ts";
import EventEmitter from "node:events";
// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: core/messaging.ipynb

const newMessageRecordSchema = z.object({
  did: z.string(),
  time_us: z.number(),
  commit: z.object({
    rev: z.string(),
    operation: z.string(),
    collection: z.string(),
    rkey: z.string(),
    cid: z.string().optional(),
    record: z.custom<Message>(),
  }),
}).transform((d) => {
  if (!d.commit) {
    throw new Error(`Invalid record: ${JSON.stringify(d, null, 2)}`);
  }
  return Object.assign({}, d, {
    time_us: `${d.time_us}`,
    uri: atURIFromParts({
      did: d.did,
      collection: d.commit.collection,
      rkey: d.commit.rkey,
    }),
  });
});

type NewMessageRecord = z.infer<typeof newMessageRecordSchema>;

const deleteMessageRecordSchema = z
  .object({
    did: z.string(),
    time_us: z.number(),
    commit: z.object({
      rev: z.string(),
      operation: z.string(),
      collection: z.string(),
      rkey: z.string(),
      cid: z.string().optional(),
    }),
  })
  .transform((d) => {
    if (!d.commit) {
      throw new Error(`Invalid record: ${JSON.stringify(d, null, 2)}`);
    }
    return Object.assign({}, d, {
      uri: atURIFromParts({
        did: d.did,
        collection: d.commit.collection,
        rkey: d.commit.rkey,
      }),
    });
  });

type DeleteMessageRecord = z.infer<typeof deleteMessageRecordSchema>;

export class MessageCursor {
  constructor(public timestamp: string, public direction: "past" | "future") {}

  public static fromString(base64Str: string): MessageCursor {
    const decoded = atob(base64Str);
    const [timestamp, direction] = decoded.split(":");
    return new MessageCursor(timestamp, direction as "past" | "future");
  }

  public toString(): string {
    return btoa(`${this.timestamp}:${this.direction}`);
  }
}

export class Messaging extends EventEmitter {
  constructor(protected db: Database) {
    super();
  }

  public connectToJetstream(jetstream: Jetstream) {
    jetstream.on(ids.ChatTinychatCoreMessage, async (event) => {
      // we only do creates for now
      if (event.commit.operation === "create") {
        const data = newMessageRecordSchema.parse(event);
        await syncUser({ did: event.did, db: this.db });
        this.receiveMessage(
          Object.assign({}, data, {
            cid: data.commit.cid!,
            m: data.commit.record,
            sender: event.did,
          }),
        );
      } else if (event.commit.operation === "delete") {
        this.deleteMessage(deleteMessageRecordSchema.parse(event));
      }
    });
  }

  public deleteMessage({ uri }: DeleteMessageRecord) {
    this.db
      .prepare(
        `UPDATE messages SET deleted_at = :time, text = '<deleted>' WHERE uri = :uri`,
      )
      .run({ uri, time: new Date().toISOString() });
  }

  public markAllMessagesAsRead({
    channel,
    server,
    user,
  }: {
    channel: string;
    server: string;
    user: string;
  }) {
    this.db
      .prepare(
        `INSERT OR REPLACE INTO read_receipts (channel, server, user, time_us) VALUES (:channel, :server, :user, :time)`,
      )
      .run({ channel, user, server, time: getTimeus() });
  }

  public receiveMessage({
    m,
    cid,
    uri,
    sender,
    time_us,
  }: {
    m: Message;
    cid: string;
    uri: string;
    sender: string;
    time_us: string;
  }) {
    this.db
      .prepare(
        `
      INSERT INTO messages (uri, cid, channel, server, text, sender, created_at, time_us, reply_to, facets, embed, langs, labels, tags) VALUES (
        :uri, :cid, :channel, :server, :text, :sender, :created_at, :time_us, :reply_to, :facets, :embed, :langs, :labels, :tags 
      )`,
      )
      .run({
        uri,
        cid,
        channel: m.channel,
        server: m.server,
        text: m.text,
        sender,
        created_at: m.createdAt,
        time_us: time_us,
        reply_to: m.reply ? m.reply.parent.uri : null,
        facets: m.facets ? JSON.stringify(m.facets) : null,
        embed: m.embed ? JSON.stringify(m.embed) : null,
        langs: m.langs ? JSON.stringify(m.langs) : null,
        labels: m.labels ? JSON.stringify(m.labels) : null,
        tags: m.tags ? JSON.stringify(m.tags) : null,
      });
    this.emit("message", { uri });
  }

  public getMessages({
    server,
    channel,
    uri,
    cursor,
    limit,
    sort = "latest",
  }: {
    server?: string;
    channel?: string;
    uri?: string;
    cursor?: string;
    limit?: number;
    sort?: "latest" | "chronological";
  }): {
    messages: MessageView[];
    prevCursor?: string;
    nextCursor?: string;
  } {
    interface Message {
      uri: string;
      cid: string;
      channel: string;
      server: string;
      text: string;
      createdAt: string;
      time_us: string;
      // user
      did: string;
      handle: string;
      displayName: string;
      avatar?: string;
      description?: string;
    }

    if (!channel && !server && !uri) {
      return {
        messages: [],
      };
    }

    const parsedCursor = cursor && MessageCursor.fromString(cursor);
    const cursorWhere = (c: MessageCursor) =>
      c.direction === "past" ? "time_us < :cursor" : "time_us > :cursor";
    let results: Message[] = [];

    if (uri) {
      results = this.db
        .prepare(`SELECT * FROM message_view WHERE uri = :uri`)
        .all<Message>(Object.assign({ uri }));
    } else {
      results = this.db
        .prepare(
          `SELECT * FROM message_view
      WHERE channel = :channel AND server = :server ${
            parsedCursor ? `AND ${cursorWhere(parsedCursor)}` : ""
          } ORDER BY ${
            sort === "chronological" ? "time_us ASC" : "time_us DESC"
          } LIMIT :limit`,
        )
        .all<Message>(
          Object.assign(
            { server, channel, limit: limit || 10 },
            parsedCursor ? { cursor: parsedCursor.timestamp } : {},
          ),
        );
    }

    const messages: MessageView[] = results
      .map((m: Message) => ({
        uri: m.uri,
        cid: m.cid,
        channel: m.channel,
        server: m.server,
        text: m.text,
        createdAt: m.createdAt,
        ts: m.time_us,
        sender: {
          did: m.did,
          handle: m.handle,
          displayName: m.displayName,
          avatar: m.avatar,
          description: m.description,
        },
      }))
      .map(removeNulls)
      .map((m) => {
        const v = validateMessageView(m);
        if (!v.success) {
          console.error("Failed to validate message view", v);
        }
        // @ts-ignore yolo
        return v.value;
      })
      .filter((m) => m) as MessageView[];

    if (sort === "latest") {
      return Object.assign(
        {
          messages,
        },
        messages.length === limit
          ? {
            prevCursor: new MessageCursor(
              messages[messages.length - 1].ts,
              "past",
            ).toString(),
          }
          : {},
        cursor
          ? {
            nextCursor: new MessageCursor(
              messages[0].ts,
              "future",
            ).toString(),
          }
          : {},
      );
    }

    // chronological ordering
    // need to check if we have older messages for the prev cursor

    const hasPreviousMessages = messages.length !== 0 &&
      this.db
          .prepare(
            `SELECT uri FROM message_view
          WHERE channel = :channel AND server = :server AND time_us < :time_us
          ORDER BY time_us DESC LIMIT :limit`,
          )
          .all<Message>({
            channel,
            server,
            time_us: messages[0].ts,
            limit: 1,
          }).length > 0;

    return Object.assign(
      {
        messages,
      },
      messages.length === limit
        ? {
          nextCursor: new MessageCursor(
            messages[messages.length - 1].ts,
            "future",
          ).toString(),
        }
        : {},
      hasPreviousMessages
        ? {
          prevCursor: new MessageCursor(messages[0].ts, "past").toString(),
        }
        : {},
    );
  }
}
