import type { Database } from "tinychat/db.ts";
import { Record as Message } from "tinychat/api/types/chat/tinychat/core/message.ts";
import {
  MessageView,
  validateMessageView,
} from "tinychat/api/types/chat/tinychat/server/defs.ts";
import { getTimeus, removeNulls } from "tinychat/utils.ts";
import { DeleteMessageRecord } from "tinychat/firehose.ts";
// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: core/messaging.ipynb

export class MessageCursor {
  constructor(public timestamp: string, public direction: "past" | "future") {}

  public static fromString(base64Str: string): MessageCursor {
    const decoded = atob(base64Str);
    const [timestamp, direction] = decoded.split(":");
    return new MessageCursor(timestamp, direction as "past" | "future");
  }

  public toString(): string {
    return btoa(`${this.timestamp}:${this.direction}`);
  }
}

export class Messaging {
  constructor(protected db: Database) {}

  public deleteMessage({ uri }: DeleteMessageRecord) {
    this.db
      .prepare(
        `UPDATE messages SET deleted_at = :time, text = '<deleted>' WHERE uri = :uri`,
      )
      .run({ uri, time: new Date().toISOString() });
  }

  public markAllMessagesAsRead({
    channel,
    server,
    user,
  }: {
    channel: string;
    server: string;
    user: string;
  }) {
    this.db
      .prepare(
        `INSERT OR REPLACE INTO read_receipts (channel, server, user, time_us) VALUES (:channel, :server, :user, :time)`,
      )
      .run({ channel, user, server, time: getTimeus() });
  }

  public receiveMessage({
    m,
    uri,
    sender,
    time_us,
  }: {
    m: Message;
    uri: string;
    sender: string;
    time_us: string;
  }) {
    this.db
      .prepare(
        `
      INSERT INTO messages (uri, channel, server, text, sender, created_at, time_us) VALUES (
        :uri, :channel, :server, :text, :sender, :created_at, :time_us
      )`,
      )
      .run({
        uri,
        channel: m.channel,
        server: m.server,
        text: m.text,
        sender,
        created_at: m.createdAt,
        time_us: time_us,
      });
  }

  public getMessages({
    server,
    channel,
    uri,
    cursor,
    limit,
    sort = "latest",
  }: {
    server?: string;
    channel?: string;
    uri?: string;
    cursor?: string;
    limit?: number;
    sort?: "latest" | "chronological";
  }): {
    messages: MessageView[];
    prevCursor?: string;
    nextCursor?: string;
  } {
    interface Message {
      uri: string;
      channel: string;
      server: string;
      text: string;
      createdAt: string;
      time_us: string;
      // user
      did: string;
      handle: string;
      displayName: string;
      avatar?: string;
      description?: string;
    }

    if (!channel && !server && !uri) {
      return {
        messages: [],
      };
    }

    const parsedCursor = cursor && MessageCursor.fromString(cursor);
    const cursorWhere = (c: MessageCursor) =>
      c.direction === "past" ? "time_us < :cursor" : "time_us > :cursor";
    let results: Message[] = [];

    if (uri) {
      results = this.db
        .prepare(`SELECT * FROM message_view WHERE uri = :uri`)
        .all<Message>(Object.assign({ uri }));
    } else {
      results = this.db
        .prepare(
          `SELECT * FROM message_view
      WHERE channel = :channel AND server = :server ${
            parsedCursor ? `AND ${cursorWhere(parsedCursor)}` : ""
          } ORDER BY ${
            sort === "chronological" ? "time_us ASC" : "time_us DESC"
          } LIMIT :limit`,
        )
        .all<Message>(
          Object.assign(
            { server, channel, limit: limit || 10 },
            parsedCursor ? { cursor: parsedCursor.timestamp } : {},
          ),
        );
    }

    const messages: MessageView[] = results
      .map((m: Message) => ({
        uri: m.uri,
        channel: m.channel,
        server: m.server,
        text: m.text,
        createdAt: m.createdAt,
        ts: m.time_us,
        sender: {
          did: m.did,
          handle: m.handle,
          displayName: m.displayName,
          avatar: m.avatar,
          description: m.description,
        },
      }))
      .map(removeNulls)
      .map((m) => {
        const v = validateMessageView(m);
        if (!v.success) {
          console.error("Failed to validate message view", v);
        }
        // @ts-ignore yolo
        return v.value;
      })
      .filter((m) => m) as MessageView[];

    if (sort === "latest") {
      return Object.assign(
        {
          messages,
        },
        messages.length === limit
          ? {
            prevCursor: new MessageCursor(
              messages[messages.length - 1].ts,
              "past",
            ).toString(),
          }
          : {},
        cursor
          ? {
            nextCursor: new MessageCursor(
              messages[0].ts,
              "future",
            ).toString(),
          }
          : {},
      );
    }

    // chronological ordering
    // need to check if we have older messages for the prev cursor

    const hasPreviousMessages = messages.length !== 0 && this.db
          .prepare(
            `SELECT uri FROM message_view
          WHERE channel = :channel AND server = :server AND time_us < :time_us
          ORDER BY time_us DESC LIMIT :limit`,
          )
          .all<Message>({
            channel,
            server,
            time_us: messages[0].ts,
            limit: 1,
          }).length > 0;

    return Object.assign(
      {
        messages,
      },
      messages.length === limit
        ? {
          nextCursor: new MessageCursor(
            messages[messages.length - 1].ts,
            "future",
          ).toString(),
        }
        : {},
      hasPreviousMessages
        ? {
          prevCursor: new MessageCursor(messages[0].ts, "past").toString(),
        }
        : {},
    );
  }
}
