import { lexicons } from "tinychat/api/lexicons.ts";
import { LexUserType, lexUserType } from "@atproto/lexicon";
import { z } from "zod";
// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: lexicons.ipynb

// get lexicon for tincychat
export const getLocalLexicon = (): ([string, LexUserType])[] => {
  return lexicons.defs
    .entries()
    .toArray()
    .filter(([name]) => name.startsWith("lex:chat.tinychat")).map((
      [name, def],
    ) => [name.replace("lex:", ""), def]);
};

// import { merman } from "tinychat/tools/merman.ts";

type LexiconObjectType = Extract<
  z.infer<typeof lexUserType>,
  { type: "object" }
>;

const getLexiconDefByName = (
  name: string,
): { name: string; def: LexUserType } | undefined => {
  const r = lexicons.defs.entries().toArray().find((e) => e[0] === name);
  return r && { name: r[0], def: r[1] };
};

// generate random alpha string
const genAlias = (length: number = 10) => {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let result = "";
  for (let i = length; i > 0; --i) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
};

const diagram = (
  name: string,
  def: LexUserType,
  defAliases: Record<string, string> = {},
): string | undefined => {
  defAliases[name] = genAlias();
  const links: string[][] = [];
  const linkedEntities: string[] = [];

  const entity = (name: string, props: string[]) => {
    const n = defAliases[name] ? `${defAliases[name]}["${name}"]` : name;
    return `${n} {
      ${props.join("\n")}
    }`;
  };

  const mapRef = (
    name: string,
    ref: string,
    refObj: LexUserType | undefined = undefined,
  ) => {
    // most of the time ref points to an existing type
    // but sometimes we need a synthetic type that does not really exist by itself (e.g. query returns an object)
    // this is what refObj is for

    // if there is existing ref, skip
    if (links.find(([, l]) => l === ref)) {
      return;
    }

    links.push([name, ref]);
    linkedEntities.push(
      diagram(ref, refObj || getLexiconDefByName(ref)!.def, defAliases)!,
    );
  };

  const renderRefs = () => {
    return (
      links
        .map(([n, l]) => [
          n,
          Object.entries(defAliases).find(([k]) => k === l)![1],
        ])
        .map(([n, l]) => `${defAliases[name]} ||--o| ${l} : ${n}`)
        .join("\n\n") +
      "\n\n" +
      linkedEntities.join("\n\n")
    );
  };

  const processObject = (o: LexiconObjectType): string[] => {
    return Object.entries(o.properties).map((prop) => {
      const [name, d] = prop;

      if (d.type === "string") {
        let t: string = d.type;
        if (d.format) {
          t = `${t}(${d.format})`;
        }
        return `${name} ${t} ${d.description ? `"${d.description}"` : ""}`;
      }

      if (d.type === "ref") {
        mapRef(name, d.ref);
      }

      if (d.type === "array") {
        if (d.items.type === "ref") {
          mapRef(name, d.items.ref);
        }
      }

      return `${name} ${d.type}`;
    });
  };

  if (def.type === "object") {
    const props = processObject(def);

    return [
      renderRefs() +
      `
    ${defAliases[name]}["${name}"] {
      ${props.join("\n")}
     }`,
    ].join("\n");
  } else if (def.type === "record") {
    return diagram(name, def.record, defAliases);
  } else if (def.type === "query" || def.type === "procedure") {
    if (def.output?.schema?.type === "ref") {
      mapRef("returns", def.output.schema.ref);
    } else if (def.output?.schema?.type === "object") {
      mapRef("returns", "returns", def.output.schema);
    }
    return [
      renderRefs(),
      // procedure body
      // @ts-ignore yolo
      entity(name, def.parameters ? processObject(def.parameters) : []),
    ].join("\n");
  }
  return "";
};

export const getDiagram = (name: string) => {
  const item = getLexiconDefByName(
    name.startsWith("lex:") ? name : `lex:${name}`,
  );
  const dc = diagram(item!.name, item!.def);
  console.log(dc);
  return `---
config:
fontSize: 18
theme: neutral
layout: elk
elk:
    mergeEdges: true
    nodePlacementStrategy: NETWORK_SIMPLEX
---
erDiagram
    ${dc}`;
};

// merman(
//   [
//     "lex:chat.tinychat.actor.getProfile",
//     "lex:chat.tinychat.core.message#main",
//     "lex:chat.tinychat.server.getServers",
//     "lex:chat.tinychat.server.createServer",
//   ].map(getDiagram),
//   `<strong>Legend:</strong>hello<hr/>`
// );
