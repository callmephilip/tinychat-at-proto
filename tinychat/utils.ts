// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: utils.ipynb

export const slugify = (str: string) => str.toLowerCase().replace(/\s/g, "-");
export const removeNulls = (input: object): object => {
  if (input === null || input === undefined) {
    return input;
  }

  if (Array.isArray(input)) {
    return input
      .filter((item) => item !== null)
      .map((item) => removeNulls(item));
  }

  if (typeof input === "object") {
    return Object.fromEntries(
      Object.entries(input as object)
        .filter(([, value]) => value !== null)
        .map(([key, value]) => [
          key,
          typeof value === "object" ? removeNulls(value) : value,
        ]),
    );
  }

  return input;
};
import linkifyStr from "linkify-string";

export const linkify = (
  input: string,
  className?: string | undefined,
): string => linkifyStr(input, { target: "_blank", className });
import path from "node:path";

export const getProjectRoot = (
  dir: string = Deno.cwd(),
  d = 0,
  maxD = 10,
): string => {
  if (d >= maxD) throw new Error("max depth reached");

  try {
    const f = path.join(dir, "deno.json");
    Deno.lstatSync(f);
    return path.dirname(f);
  } catch {
    return getProjectRoot(path.join(dir, "../"), d + 1);
  }
};
const processLine = (line: string): string => {
  if (!line.trim().match(/^import|export/ig)) {
    return line;
  }
  const module = line.split("from").pop()?.trim().replaceAll(/'|"|;/ig, "");
  if (!module || !module.startsWith(".") || module.endsWith(".ts")) {
    return line;
  }
  return line.replace(module!, `${module}.ts`);
};
const processFile = async (file: string): Promise<string> => {
  const text = await Deno.readTextFile(file);
  const modifiedText = text.split("\n").map(processLine).join("\n");
  await Deno.writeTextFile(file, modifiedText);
  return modifiedText;
};

import { walk } from "jsr:@std/fs/walk";

export const unslopifyModules = async (dir: string) => {
  for await (const dirEntry of walk(dir, { exts: ["ts"] })) {
    await processFile(dirEntry.path);
  }
};
export const getTimeus = (): string => `${new Date().getTime() * 1000}`;
export const sleep = (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));
export const shortIdFromAtUri = (atUri: string) => {
  return atUri.split("/").pop();
};
export const atURIFromParts = ({
  did,
  collection,
  rkey,
}: {
  did: string;
  collection: string;
  rkey: string;
}): string => `at://${did}/${collection}/${rkey}`;
import { ids } from "tinychat/api/lexicons.ts";
import { ChannelView } from "tinychat/api/types/chat/tinychat/server/defs.ts";

export const serverAtURIFromUrl = (url: string, prefix: string = "chat") => {
  const parts = url.split("?")[0].split("/" + prefix)[1].replace(/^\//ig, "")
    .split(
      "/",
    );
  return `at://did:plc:${parts[0]}/${ids.ChatTinychatCoreServer}/${parts[1]}`;
};

export const urlFromServerAtURI = (atUri: string, prefix: string = "chat") => {
  const parts = atUri.split(ids.ChatTinychatCoreServer);
  //@ts-ignore yolo
  const did = parts[0].split(":").pop().replace("/", "");
  //@ts-ignore yolo
  const rkey = parts[1].replace("/", "");
  return `/${prefix}/${did}/${rkey}`;
};

export const urlForChannelMessageList = (channel: ChannelView) => {
  return urlFromServerAtURI(channel.server).replace("/chat", "/messages/list") +
    "/" + channel.id;
};

export const parseURLForChannelMessageList = (
  url: string,
): { server: string; channel: string } => {
  const parts = url.replace("/messages/list/", "").split("/");
  // "/messages/list/ubdeopbbkbgedccgbum7dhsh/3lgawfvbbtx2b/abc";
  console.log(parts);
  return {
    server: `at://did:plc:${parts[0]}/${ids.ChatTinychatCoreServer}/${
      parts[1]
    }`,
    channel: parts[2],
  };
};
